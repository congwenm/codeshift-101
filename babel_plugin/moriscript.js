// helper method
module.exports = function (babel) {
  var t = babel.types;

  function moriMethod(name) {
    var expr = t.memberExpression(
      t.identifier('mori'),
      t.identifier(name)
    )
    expr.isClean = true
    return expr
  }

  return {
    visitor: {
      ArrayExpression: function(path) {
        path.replaceWith(
          t.callExpression(
            t.memberExpression(
              t.identifier('mori'),
              t.identifier('vector')
            ),
            path.node.elements
          )
        )
      },

      ObjectExpression: function(path) {

        // get a list of names
        var props = [];
        path.node.properties.forEach(prop =>
          props.push(
            t.stringLiteral(prop.key.name),
            prop.value
          )
        )

        path.replaceWith(
          t.callExpression(
            moriMethod('hashMap'),
            // alternative:
            // t.memberExpression(
            //   t.identifier('mori'),
            //   t.identifier('hashMap')
            // ),
            props
          )
        )
      },

      AssignmentExpression: path => {
        var lhs = path.node.left
        var rhs = path.node.right

        // TODO: note: need to make a prelimiary check to see if expresion on left is a MemberExpression, we dont want to mess with `var a = 3`
        if(t.isMemberExpression(lhs)) {
          // TODO: note, if its identifier, convert to literal
          if(t.isIdentifier(lhs.property)) {
            lhs.property = t.stringLiteral(lhs.property.name)
          }

          path.replaceWith(
            t.callExpression(
              moriMethod('assoc'),
              [lhs.object, lhs.property, rhs]
            )
          )
        }
      },

      MemberExpression: path => {
        // TODO: note if this was generated by `moriMethod`
        if (path.node.isClean) return;

        // TODO: note if parent is assignment, we want to let assignemnt expression visitor deal with this
        if (t.isAssignmentExpression(path.parent)) return;

        if (t.isIdentifier(path.node.property)) {
          path.node.property = t.stringLiteral(path.node.property.name);
        }

        var { property, object } = path.node;
        path.replaceWith(
          t.callExpression(
            moriMethod('get'), // causes stack overflow b/c we replace MemberExpression with another MemberExpression
            [
              object,
              property
            ]
          )
        )
      }
    }
  }
}